name: Deploy Blog & Notify New Post to Telegram # 工作流程名稱，改為部署與通知

# 當有新的 push 事件發生時觸發此 workflow
on:
  push:
    branches:
      - main # 請將此處改為您儲存庫的主要分支名稱，例如 master
    paths:
      - 'blog/**' # 監聽 'blog/' 目錄下的任何檔案變動
      - 'blog/**/*' # 確保涵蓋 'blog/' 子目錄中的變動

jobs:
  # --- 第一個 Job: 負責建置和部署 GitHub Pages ---
  build_and_deploy_pages:
    runs-on: ubuntu-latest
    # 【重要】設定 environment，這是 GitHub Pages 部署所需的
    environment:
      name: github-pages
    permissions:
      contents: read
      pages: write # 部署 Pages 需要寫入權限
      id-token: write # 部署 Pages 需要這個權限

    outputs:
      # 將偵測到的新檔案列表輸出，供後續 notify_new_post job 使用
      new_post_files: <span class="math-inline">\{\{ steps\.get\-new\-files\.outputs\.NEW\_POST\_FILES \}\}
steps\:
\- name\: Checkout repository for build
uses\: actions/checkout@v4
with\:
fetch\-depth\: 0 \# 獲取所有歷史紀錄，以便 git diff 能正確判斷「新增」的檔案
\- name\: Get new files in target directory \(for decision making\)
id\: get\-new\-files \# 保留 ID 以便輸出
run\: \|
TARGET\_DIR\="blog/"
CURRENT\_SHA\="</span>{{ github.sha }}"
          LAST_COMMIT_SHA=<span class="math-inline">\(git rev\-parse "</span>{CURRENT_SHA}~1" 2>/dev/null || echo "")

          # 將原始偵測到的檔案路徑寫入臨時文件
          temp_raw_detected_files="temp_raw_detected_files.txt"
          > "$temp_raw_detected_files" # 清空或建立文件

          if [ -z "$LAST_COMMIT_SHA" ]; then
            # 對於儲存庫的第一次 push，所有符合條件的文件都視為「新增」
            find "$TARGET_DIR" -type f -print0 | xargs -0 -r -n 1 echo >> "<span class="math-inline">temp\_raw\_detected\_files"
else
\# 比較本次 push 和上一個 commit 之間的差異，只篩選新增的檔案
git diff \-\-name\-only \-\-diff\-filter\=A "</span>{LAST_COMMIT_SHA}" "${CURRENT_SHA}" -- "$TARGET_DIR" -z | xargs -0 -r -n 1 echo >> "$temp_raw_detected_files"
          fi

          NEW_POST_FILES_FINAL="" # 最終要輸出的乾淨檔案列表
          # 檢查是否有任何檔案被偵測到
          if [ -s "$temp_raw_detected_files" ]; then # -s 檢查檔案是否存在且不為空
            # 使用 while read 迴圈安全地讀取檔案中的每一行 (檔名)
            while IFS= read -r file; do
              # 【加強防呆】確保檔案存在且是普通文件，並且在目標目錄下
              if [ -f "$file" ] && [[ "$file" == "$TARGET_DIR"* ]]; then
                # 如果 NEW_POST_FILES_FINAL 不為空，則先加換行符號
                [ -n "<span class="math-inline">NEW\_POST\_FILES\_FINAL" \] && NEW\_POST\_FILES\_FINAL\+\=</span>'\n'
                NEW_POST_FILES_FINAL+="$file"
              else
                echo "Warning: Skipped non-existent or invalid file detected: ${file}"
              fi
            done < "$temp_raw_detected_files"
          fi

          echo "Detected NEW files in <span class="math-inline">\{TARGET\_DIR\} directory\:"
echo "</span>{NEW_POST_FILES_FINAL}" # 這裡直接輸出 NEW_POST_FILES_FINAL 的內容，會保留換行

          # 將結果輸出給下一個步驟
          echo "NEW_POST_FILES=${NEW_POST_FILES_FINAL}" >> "$GITHUB_OUTPUT"

      # --- 【這裡放您的部落格建置指令】 ---
      # 這個步驟會生成您的靜態網站檔案，並放到 _site 或 public 目錄
      - name: Build Your Blog
        # 請在這裡替換成您實際部落格的建置指令。例如：
        # run: bundle install && bundle exec jekyll build
        # run: hugo
        # run: npm install && hexo generate
        run: |
          echo "這裡是您部落格的建置指令。它會產生靜態檔案到 _site 或 public 目錄。"
          # 以下是為了示範而放置的模擬指令，請務必替換為您真實的建置指令
          mkdir -p _site 
          echo "<h1>這是首頁</h1>" > _site/index.html
          mkdir -p _site/blog
          echo "<h1>Hello World! 這是一篇新文章</h1>" > _site/blog/first-new-article.html
          # 模擬指令結束，請移除或替換上方這些模擬指令為您真實的建置指令

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './_site' # 確保這裡的路徑與您部落格實際的輸出目錄一致 (例如 _site 或 public)

      - name: Deploy to GitHub Pages
        id: deployment # 給這個步驟一個 ID，方便後續引用
        uses: actions/deploy-pages@v4
        env:
          GITHUB_TOKEN: <span class="math-inline">\{\{ secrets\.GITHUB\_TOKEN \}\}
\# \-\-\- 第二個 Job\: 發送 Telegram 通知 \(在 Pages 部署成功後\) \-\-\-
notify\_new\_post\:
runs\-on\: ubuntu\-latest
needs\: build\_and\_deploy\_pages \# <\-\-\- 【關鍵】這個 Job 會在 build\_and\_deploy\_pages 成功後才執行
\# 只有當 build\_and\_deploy\_pages 成功且有新檔案被偵測到時才執行通知
if\: success\(\) && needs\.build\_and\_deploy\_pages\.outputs\.new\_post\_files \!\= ''
steps\:
\- name\: Checkout repository \# 重新檢出，以便讀取文章內容
uses\: actions/checkout@v4
\# 這裡不需要 fetch\-depth\: 0，因為我們只讀取檔案
\- name\: Process and send Telegram notification \# 步驟 3\: 處理檔案並發送 Telegram 通知
run\: \|
TELEGRAM\_BOT\_TOKEN\="</span>{{ secrets.TELEGRAM_BOT_TOKEN }}"
          TELEGRAM_CHAT_ID="<span class="math-inline">\{\{ secrets\.TELEGRAM\_CHAT\_ID \}\}"
\# 從上一個 Job 獲取偵測到的新文章檔案列表
NEW\_POST\_FILES\="</span>{{ needs.build_and_deploy_pages.outputs.new_post_files }}"
          
          # 【重要設定】您的網站基礎網址
          BASE_URL="https://holybear.me"

          # 【加強防呆】檢查 NEW_POST_FILES 是否為空或只包含空白
          if [[ -z "<span class="math-inline">\{NEW\_POST\_FILES// /\}" \]\]; then \# 移除所有空白後判斷是否為空
echo "No valid new files detected for notification, skipping\."
exit 0 \# 提前結束，不發送通知
fi
\# 遍歷每個新增的檔案
\# 注意：為了安全處理檔名中的空白，這裡使用 IFS 和 read \-r
IFS\=</span>'\n' # 設定內部欄位分隔符為換行符，確保檔名中的空白不會被錯誤地拆分
          for file_path_raw in <span class="math-inline">\{NEW\_POST\_FILES\}; do
\# 【關鍵】徹底清理 file\_path\_raw，確保它只是一個乾淨的檔案路徑
\# 這能處理可能存在的額外空白或隱形字元
file\_path\="</span>(echo "<span class="math-inline">\{file\_path\_raw\}" \| xargs\)"
\# 【加強防呆】再次檢查檔案是否存在且是普通文件，避免處理無效路徑
if \[ \! \-f "</span>{file_path}" ]; then
              echo "Warning: File not found or not a regular file: ${file_path}, skipping."
              continue # 跳過當前迴圈，處理下一個檔案
            fi

            echo "Processing file: <span class="math-inline">\{file\_path\}"
\# 讀取檔案內容
file\_content\="</span>(cat "${file_path}")"
            
            # 從 Markdown 檔案內容中提取 title (優先從 Front Matter 提取)
            # 【修正】awk: 將雙引號的正規表達式從 `\"` 改為 `"`，並使用 gsub 處理單引號
            TITLE="<span class="math-inline">\(echo "</span>{file_content}" | awk '
              /^---$/ { count++; if (count == 2) exit; next }
              (count == 1 && /^\s*title:/) {
                gsub(/^\s*title:\s*/, "", $0);
                gsub(/[\r\n]/, " ", $0);      # 移除換行符 (CR 和 LF)
                gsub(/"/, "", $0);           # 移除雙引號
                gsub(/\x27/, "", $0);        # 移除單引號 (十六進位碼)
                print <span class="math-inline">0;
exit
\}
' \| xargs\)" \# 再次用 xargs 清理前後空白及任何隱形字元
\# 如果 Front Matter 中沒有 title，則嘗試從 H1 標題提取
\# 【修正】sed\: 將雙引號和單引號的移除分開處理，並確保正規表達式正確
if \[\[ \-z "</span>{TITLE}" ]]; then
              TITLE="<span class="math-inline">\(echo "</span>{file_content}" | grep -iE '^#\s*(.*)' | head -n 1 | sed -E 's/^#\s*(.*)/\1/' | sed -E 's/[\r\n]//g' | sed -E 's/"//g' | sed -E 's/\x27//g' | xargs)" # 移除雙引號和單引號
            fi
            # 如果仍然沒有標題，設定為預設值
            if [[ -z "<span class="math-inline">\{TITLE\}" \]\]; then
TITLE\="無標題文章"
fi
\# 【最新修正】使用 grep 和 sed 來提取 category，更穩定處理多種 YAML 格式
\# 【修正】sed\: 將雙引號和單引號的移除分開處理，並確保正規表達式正確
CATEGORY\=""
CATEGORY\_RAW\="</span>(echo "<span class="math-inline">\{file\_content\}" \| grep \-A 1 \-E '^\\s\*category\:' \| grep \-E '^\\s\*\-\\s\*' \| head \-n 1 \| sed \-E 's/^\\s\*\-\\s\*\(\.\*\)/\\1/' \| sed \-E 's/\[\\r\\n\]//g' \| sed \-E 's/"//g' \| sed \-E 's/\\x27//g' \| xargs\)" \# 移除雙引號和單引號
\# 只有當 CATEGORY\_RAW 包含有效字元時才賦值給 CATEGORY
if \[\[ \-n "</span>{CATEGORY_RAW}" ]]; then
              CATEGORY="<span class="math-inline">\{CATEGORY\_RAW\}"
\# 再次清理確保沒有任何特殊字元可能被誤解
\# 這裡用 tr \-cd 來只保留特定字元，並用 xargs 清理多餘空白
CATEGORY\="</span>(echo "<span class="math-inline">\{CATEGORY\}" \| tr \-cd '\[\:alnum\:\] \_\-'\)" \# 只保留字母數字、空白、底線、破折號
CATEGORY\="</span>(echo "<span class="math-inline">\{CATEGORY\}" \| xargs\)" \# 清理因替換可能產生的多餘空白
fi
if \[\[ \-z "</span>{CATEGORY}" ]]; then # 如果第一個提取方式沒結果，嘗試第二種
              CATEGORY_RAW="<span class="math-inline">\(echo "</span>{file_content}" | grep -iE '^\s*category:\s*\[.*\]' | head -n 1 | sed -E 's/^\s*category:\s*\[(.*)\].*/\1/' | cut -d',' -f1 | sed -E 's/[\r\n]//g' | sed -E 's/"//g' | sed -E 's/\x27//g' | xargs)"
              if [[ -n "<span class="math-inline">\{CATEGORY\_RAW\}" \]\]; then
CATEGORY\="</span>{CATEGORY_RAW}"
                CATEGORY="<span class="math-inline">\(echo "</span>{CATEGORY}" | tr -cd '[:alnum:] _-')"
                CATEGORY="<span class="math-inline">\(echo "</span>{CATEGORY}" | xargs)"
              fi
            fi
            if [[ -z "<span class="math-inline">\{CATEGORY\}" \]\]; then \# 如果第二種也沒結果，嘗試第三種
CATEGORY\_RAW\="</span>(echo "<span class="math-inline">\{file\_content\}" \| grep \-iE '^\\s\*category\:\\s\*\[^\\\[\-\]' \| head \-n 1 \| sed \-E 's/^\\s\*category\:\\s\*\(\.\*\)/\\1/' \| sed \-E 's/\[\\r\\n\]//g' \| sed \-E 's/^"\|"//g' \| sed \-E 's/\\x27//g' \| xargs\)"
if \[\[ \-n "</span>{CATEGORY_RAW}" ]]; then
                CATEGORY="<span class="math-inline">\{CATEGORY\}"
CATEGORY\=</span>(echo "<span class="math-inline">\{CATEGORY\}" \| tr \-cd '\[\:alnum\:\] \_\-'\)
CATEGORY\=</span>(echo "<span class="math-inline">\{CATEGORY\}" \| xargs\)
fi
fi
\# 這個最終的清理保留，因為它處理的是 CATEGORY 變數可能在最後仍有的前後空白或引號問題
\# CATEGORY\=</span>(echo "<span class="math-inline">\{CATEGORY\}" \| sed \-E 's/^\[\[\:space\:\]\]\+\|\[\[\:space\:\]\]\+</span>//g') # 移除前後空白
            # CATEGORY=<span class="math-inline">\(echo "</span>{CATEGORY}" | sed -E 's/[\x27"\/]//g') # 移除單引號、雙引號、斜線 (這裡的 / 已經是字元，不需要跳脫)

            if [[ -n "<span class="math-inline">\{CATEGORY\}" \]\]; then
TITLE\="【</span>{CATEGORY}】<span class="math-inline">\{TITLE\}"
fi
\# 產生文章連結的邏輯
ARTICLE\_SLUG\="</span>(echo "<span class="math-inline">\{file\_path\}" \| sed \-E 's\|^blog/\(\.\*\)\\\.md</span>|\1|')"
            ARTICLE_URL="<span class="math-inline">\{BASE\_URL\}/blog/</span>{ARTICLE_SLUG}.html" # 假設您的文章是 .html 結尾

            # 組裝 Telegram 訊息
            # 【修正】確保即使 TITLE 或 commit message 為空，訊息也不會完全為空
            MESSAGE="**📢 New push to GitHub**\n"
            if [[ -n "<span class="math-inline">\{TITLE\}" \]\]; then
MESSAGE\+\="\*\*</span>{TITLE}**\n"
            else
                MESSAGE+="**(無標題文章)**\n" # 如果沒有標題，提供一個預設標題
            fi

            COMMIT_MESSAGE="<span class="math-inline">\{\{ github\.event\.head\_commit\.message \}\}"
if \[\[ \-n "</span>{COMMIT_MESSAGE}" ]]; then
                MESSAGE+="```${COMMIT_MESSAGE}```\n"
            else
                MESSAGE+="```(無提交訊息)```\n" # 如果沒有提交訊息，提供一個預設值
            fi
            
            MESSAGE+="[>>點此閱讀文章](${ARTICLE_URL})\n"
            MESSAGE+="by ${{ github.event.head_commit.author.name }}"

            # 發送 Telegram 訊息
            # 【修正】確保 ENCODED_MESSAGE 中的斜線 `/` 和百分比符號 `%` 被正確跳脫，避免 URL 編碼問題
            ENCODED_MESSAGE=<span class="math-inline">\(echo \-e "</span>{MESSAGE}" | sed -E 's/([_*\[\]()~`>#+\-=|{}!.\\])/\\\1/g' | sed 's/\//\\\//g' | sed 's/%/%25/g' | sed 's/ /%20/g' | sed 's/\n/%0A/g' | sed 's/\*/%2A/g' | sed 's/\[/%5B/g' | sed 's/\]/%5D/g' | sed 's/(/%28/g' | sed 's/)/%29/g' | sed 's/`/%60/g' | sed 's/{/%7B/g' | sed 's/}/%7D/g' | sed 's/~/%7E/g' | sed 's/\./%2E/g')

            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -d "chat_id=<span class="math-inline">\{TELEGRAM\_CHAT\_ID\}" \\
\-d "text\=</span>{ENCODED_MESSAGE}" \
              -d "parse_mode=MarkdownV2" # 確保這裡使用 MarkdownV2
            echo "Telegram notification sent for ${file_path} with title: ${TITLE}"
          done
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
