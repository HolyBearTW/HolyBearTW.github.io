name: Deploy Blog & Notify New Post to Telegram # 工作流程名稱，改為部署與通知

# 當有新的 push 事件發生時觸發此 workflow
on:
  push:
    branches:
      - main # 請將此處改為您儲存庫的主要分支名稱，例如 master
    paths:
      - 'blog/**' # 監聽 'blog/' 目錄下的任何檔案變動
      - 'blog/**/*' # 確保涵蓋 'blog/' 子目錄中的變動

jobs:
  # --- 第一個 Job: 負責建置和部署 GitHub Pages ---
  build_and_deploy_pages:
    runs-on: ubuntu-latest
    # 【重要】設定 environment，這是 GitHub Pages 部署所需的
    environment:
      name: github-pages
    permissions:
      contents: read
      pages: write # 部署 Pages 需要寫入權限
      id-token: write # 部署 Pages 需要這個權限

    outputs:
      # 將偵測到的新檔案列表輸出，供後續 notify_new_post job 使用
      new_post_files: ${{ steps.get-new-files.outputs.NEW_POST_FILES }}

    steps:
      - name: Checkout repository for build
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # 獲取所有歷史紀錄，以便 git diff 能正確判斷「新增」的檔案

      - name: Get new files in target directory (for decision making)
        id: get-new-files # 保留 ID 以便輸出
        run: |
          TARGET_DIR="blog/"
          CURRENT_SHA="${{ github.sha }}"
          LAST_COMMIT_SHA=$(git rev-parse "${CURRENT_SHA}~1" 2>/dev/null || echo "")

          # 將原始偵測到的檔案路徑寫入臨時文件
          temp_raw_detected_files="temp_raw_detected_files.txt"
          > "$temp_raw_detected_files" # 清空或建立文件

          if [ -z "$LAST_COMMIT_SHA" ]; then
            # 對於儲存庫的第一次 push，所有符合條件的文件都視為「新增」
            find "$TARGET_DIR" -type f -print0 | xargs -0 -r -n 1 echo >> "$temp_raw_detected_files"
          else
            # 比較本次 push 和上一個 commit 之間的差異，只篩選新增的檔案
            git diff --name-only --diff-filter=A "${LAST_COMMIT_SHA}" "${CURRENT_SHA}" -- "$TARGET_DIR" -z | xargs -0 -r -n 1 echo >> "$temp_raw_detected_files"
          fi

          NEW_POST_FILES_FINAL="" # 最終要輸出的乾淨檔案列表
          # 檢查是否有任何檔案被偵測到
          if [ -s "$temp_raw_detected_files" ]; then # -s 檢查檔案是否存在且不為空
            # 使用 while read 迴圈安全地讀取檔案中的每一行 (檔名)
            while IFS= read -r file; do
              # 【加強防呆】確保檔案存在且是普通文件，並且在目標目錄下
              if [ -f "$file" ] && [[ "$file" == "$TARGET_DIR"* ]]; then
                # 如果 NEW_POST_FILES_FINAL 不為空，則先加換行符號
                [ -n "$NEW_POST_FILES_FINAL" ] && NEW_POST_FILES_FINAL+=$'\n'
                NEW_POST_FILES_FINAL+="$file"
              else
                echo "Warning: Skipped non-existent or invalid file detected: ${file}"
              fi
            done < "$temp_raw_detected_files"
          fi

          echo "Detected NEW files in ${TARGET_DIR} directory:"
          echo "${NEW_POST_FILES_FINAL}" # 這裡直接輸出 NEW_POST_FILES_FINAL 的內容，會保留換行

          # 將結果輸出給下一個步驟
          echo "NEW_POST_FILES=${NEW_POST_FILES_FINAL}" >> "$GITHUB_OUTPUT"

      # --- 【這裡放您的部落格建置指令】 ---
      # 這個步驟會生成您的靜態網站檔案，並放到 _site 或 public 目錄
      - name: Build Your Blog
        # 請在這裡替換成您實際部落格的建置指令。例如：
        # run: bundle install && bundle exec jekyll build
        # run: hugo
        # run: npm install && hexo generate
        run: |
          echo "這裡是您部落格的建置指令。它會產生靜態檔案到 _site 或 public 目錄。"
          # 以下是為了示範而放置的模擬指令，請務必替換為您真實的建置指令
          mkdir -p _site 
          echo "<h1>這是首頁</h1>" > _site/index.html
          mkdir -p _site/blog
          echo "<h1>Hello World! 這是一篇新文章</h1>" > _site/blog/first-new-article.html
          # 模擬指令結束，請移除或替換上方這些模擬指令為您真實的建置指令

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './_site' # 確保這裡的路徑與您部落格實際的輸出目錄一致 (例如 _site 或 public)

      - name: Deploy to GitHub Pages
        id: deployment # 給這個步驟一個 ID，方便後續引用
        uses: actions/deploy-pages@v4
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # --- 第二個 Job: 發送 Telegram 通知 (在 Pages 部署成功後) ---
  notify_new_post:
    runs-on: ubuntu-latest
    needs: build_and_deploy_pages # <--- 【關鍵】這個 Job 會在 build_and_deploy_pages 成功後才執行

    # 只有當 build_and_deploy_pages 成功且有新檔案被偵測到時才執行通知
    if: success() && needs.build_and_deploy_pages.outputs.new_post_files != ''

    steps:
      - name: Checkout repository # 重新檢出，以便讀取文章內容
        uses: actions/checkout@v4
        # 這裡不需要 fetch-depth: 0，因為我們只讀取檔案

      - name: Process and send Telegram notification # 步驟 3: 處理檔案並發送 Telegram 通知
        run: |
          TELEGRAM_BOT_TOKEN="${{ secrets.TELEGRAM_BOT_TOKEN }}"
          TELEGRAM_CHAT_ID="${{ secrets.TELEGRAM_CHAT_ID }}"
          NEW_POST_FILES="${{ needs.build_and_deploy_pages.outputs.new_post_files }}"
          BASE_URL="https://holybear.me"

          if [[ -z "${NEW_POST_FILES// /}" ]]; then
            echo "No valid new files detected for notification, skipping."
            exit 0
          fi

          IFS=$'\n'
          for file_path_raw in ${NEW_POST_FILES}; do
            file_path="$(echo "${file_path_raw}" | xargs)"
            if [ ! -f "${file_path}" ]; then
              echo "Warning: File not found or not a regular file: ${file_path}, skipping."
              continue
            fi

            echo "Processing file: ${file_path}"
            file_content="$(cat "${file_path}")"

            # 提取 title (優先從 Front Matter 提取)
            TITLE="$(echo "${file_content}" | awk '
              /^---$/ { count++; next }
              (count == 1 && /^\s*title:/) {
                gsub(/^\s*title:\s*/, "", $0);
                gsub(/["\x27\r\n]/, "", $0); # 移除雙引號、單引號、CR 和 LF
                print $0;
                exit
              }
            ' | xargs)" # 確保最終輸出無前後空白

            # H1 標題 fallback
            if [[ -z "$TITLE" ]]; then
              TITLE="$(echo "$file_content" | grep -iE '^#\s*(.*)' | head -n1 | sed -E 's/^#\s*//' | sed -E 's/[\r\n]//g' | sed -E 's/["\x27]//g' | xargs)" # 精確移除引號和換行
            fi
            [[ -z "$TITLE" ]] && TITLE="無標題文章" # 若仍無標題，設為預設值

            # 提取 category
            CATEGORY=""
            CATEGORY_RAW="$(echo "${file_content}" | grep -A 1 -E '^\s*category:' | grep -E '^\s*-\s*' | head -n1 | sed -E 's/^\s*-\s*//' | sed -E 's/[\r\n]//g' | sed -E 's/["\x27]//g' | xargs)" # 精確移除引號和換行
            
            [[ -n "$CATEGORY_RAW" ]] && CATEGORY="$CATEGORY_RAW" # 如果提取到 CATEGORY_RAW 則賦值

            if [[ -z "$CATEGORY" ]]; then # 嘗試第二種 category 格式
              CATEGORY_RAW="$(echo "${file_content}" | grep -iE '^\s*category:\s*\[.*\]' | head -n1 | sed -E 's/^\s*category:\s*\[(.*)\].*/\1/' | cut -d',' -f1 | sed -E 's/[\r\n]//g' | sed -E 's/["\x27]//g' | xargs)"
              [[ -n "$CATEGORY_RAW" ]] && CATEGORY="$CATEGORY_RAW"
            fi
            if [[ -z "$CATEGORY" ]]; then # 嘗試第三種 category 格式
              CATEGORY_RAW="$(echo "${file_content}" | grep -iE '^\s*category:\s*[^\[-]' | head -n1 | sed -E 's/^\s*category:\s*//' | sed -E 's/[\r\n]//g' | sed -E 's/["\x27]//g' | xargs)"
              [[ -n "$CATEGORY_RAW" ]] && CATEGORY="$CATEGORY_RAW"
            fi
            
            # 【關鍵優化】tr -cd 中加入中文字元範圍，並強化 xargs 清理
            CATEGORY="$(echo "$CATEGORY" | tr -cd '[:alnum:] _-一-龥')" # 只保留字母數字、空白、底線、破折號和中文字符
            CATEGORY="$(echo "$CATEGORY" | xargs)" # 最終清理因替換可能產生的多餘空白

            [[ -n "$CATEGORY" ]] && TITLE="【${CATEGORY}】${TITLE}" # 若有分類，則加到標題前

            ARTICLE_SLUG="$(echo "$file_path" | sed -E 's|^blog/(.*)\.md$|\1|')"
            ARTICLE_URL="${BASE_URL}/blog/${ARTICLE_SLUG}.html" # 假設您的文章是 .html 結尾

            # 組裝訊息，利用 Bash 參數擴展預設值，確保內容不為空
            COMMIT_MESSAGE="${{ github.event.head_commit.message }}"
            AUTHOR="${{ github.event.head_commit.author.name }}"
            
            MESSAGE="**📢 New push to GitHub**\n"
            MESSAGE+="**${TITLE}**\n"
            MESSAGE+="\`\`\`${COMMIT_MESSAGE:-無提交訊息}\`\`\`\n" # 如果提交訊息為空，顯示「無提交訊息」
            MESSAGE+="[>>點此閱讀文章](${ARTICLE_URL})\n"
            MESSAGE+="by ${AUTHOR:-unknown}" # 如果作者名稱為空，顯示「unknown」

            # 【新增 Debug 輸出】
            echo "DEBUG: Final MESSAGE content:"
            echo "${MESSAGE}"
            
            # 【關鍵修正】ENCODED_MESSAGE 的 sed 跳脫符號，完全按照 GitHub AI 建議
            ENCODED_MESSAGE="$(echo -e "${MESSAGE}" \
              | sed -E 's/([_*\[\]()~`>#+\-=\|!.\\\[\]])/\\\1/g' \
              | sed 's/{/\\{/g' \
              | sed 's/}/\\}/g' \
              | sed 's/\//\\\//g' \
              | sed 's/%/%25/g' \
              | sed 's/ /%20/g' \
              | sed 's/\n/%0A/g')"

            echo "DEBUG: Final ENCODED_MESSAGE content:"
            echo "${ENCODED_MESSAGE}"

            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -d "chat_id=${TELEGRAM_CHAT_ID}" \
              -d "text=${ENCODED_MESSAGE}" \
              -d "parse_mode=MarkdownV2" # 確保這裡使用 MarkdownV2
            echo "Telegram notification sent for ${file_path} with title: ${TITLE}"
          done
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
