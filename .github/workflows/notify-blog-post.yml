name: Deploy Blog & Notify New Post to Telegram

on:
  push:
    branches:
      - main
    paths:
      - 'blog/**'
      - 'blog/**/*'

jobs:
  build_and_deploy_pages:
    runs-on: ubuntu-latest
    environment:
      name: github-pages
    permissions:
      contents: read
      pages: write
      id-token: write

    outputs:
      new_post_files: ${{ steps.get-new-files.outputs.NEW_POST_FILES }}

    steps:
      - name: Checkout repository for build
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get new files in target directory (for decision making)
        id: get-new-files
        run: |
          TARGET_DIR="blog/"
          CURRENT_SHA="${{ github.sha }}"
          LAST_COMMIT_SHA=$(git rev-parse "${CURRENT_SHA}~1" 2>/dev/null || echo "")

          temp_raw_detected_files="temp_raw_detected_files.txt"
          > "$temp_raw_detected_files"

          if [ -z "$LAST_COMMIT_SHA" ]; then
            find "$TARGET_DIR" -type f -print0 | xargs -0 -r -n 1 echo >> "$temp_raw_detected_files"
          else
            git diff --name-only --diff-filter=A "${LAST_COMMIT_SHA}" "${CURRENT_SHA}" -- "$TARGET_DIR" -z | xargs -0 -r -n 1 echo >> "$temp_raw_detected_files"
          fi

          NEW_POST_FILES_FINAL=""
          if [ -s "$temp_raw_detected_files" ]; then
            while IFS= read -r file; do
              if [ -f "$file" ] && [[ "$file" == "$TARGET_DIR"* ]]; then
                [ -n "$NEW_POST_FILES_FINAL" ] && NEW_POST_FILES_FINAL+=$'\n'
                NEW_POST_FILES_FINAL+="$file"
              else
                echo "Warning: Skipped non-existent or invalid file detected: ${file}"
              fi
            done < "$temp_raw_detected_files"
          fi

          echo "Detected NEW files in ${TARGET_DIR} directory:"
          echo "${NEW_POST_FILES_FINAL}"

          echo "NEW_POST_FILES=${NEW_POST_FILES_FINAL}" >> "$GITHUB_OUTPUT"

      - name: Build Your Blog
        run: |
          echo "ÈÄôË£°ÊòØÊÇ®ÈÉ®ËêΩÊ†ºÁöÑÂª∫ÁΩÆÊåá‰ª§„ÄÇÂÆÉÊúÉÁî¢ÁîüÈùúÊÖãÊ™îÊ°àÂà∞ _site Êàñ public ÁõÆÈåÑ„ÄÇ"
          mkdir -p _site 
          echo "<h1>ÈÄôÊòØÈ¶ñÈ†Å</h1>" > _site/index.html
          mkdir -p _site/blog
          echo "<h1>Hello World! ÈÄôÊòØ‰∏ÄÁØáÊñ∞ÊñáÁ´†</h1>" > _site/blog/first-new-article.html

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './_site'

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  notify_new_post:
    runs-on: ubuntu-latest
    needs: build_and_deploy_pages

    if: success() && needs.build_and_deploy_pages.outputs.new_post_files != ''

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Process and send Telegram notification
        run: |
          TELEGRAM_BOT_TOKEN="${{ secrets.TELEGRAM_BOT_TOKEN }}"
          TELEGRAM_CHAT_ID="${{ secrets.TELEGRAM_CHAT_ID }}"
          NEW_POST_FILES="${{ needs.build_and_deploy_pages.outputs.new_post_files }}"
          BASE_URL="https://holybear.me"

          if [[ -z "${NEW_POST_FILES// /}" ]]; then
            echo "No valid new files detected for notification, skipping."
            exit 0
          fi

          IFS=$'\n'
          for file_path_raw in ${NEW_POST_FILES}; do
            file_path="$(echo "${file_path_raw}" | xargs)"

            if [ ! -f "${file_path}" ]; then
              echo "Warning: File not found or not a regular file: ${file_path}, skipping."
              continue
            fi

            echo "Processing file: ${file_path}"
            file_content="$(cat "${file_path}")"

            # Robust title extraction
            TITLE="$(awk '
              /^---$/ { count++; next }
              (count == 1 && $0 ~ /^\s*title:/) {
                sub(/^\s*title:\s*/, ""); 
                gsub(/^[\"\047]+|[\"\047]+$/, ""); 
                print; 
                exit
              }
            ' <<< "$file_content" | xargs)"

            # Try H1 if title not found
            if [[ -z "$TITLE" ]]; then
              TITLE="$(echo "$file_content" | grep -iE '^#\s*(.*)' | head -n 1 | sed -E 's/^#\s*(.*)/\1/' | sed -E 's/[\r\n]//g' | sed -E 's/^"|"//g' | sed -E "s/^\x27|\x27//g" | xargs)"
            fi
            if [[ -z "$TITLE" ]]; then
              TITLE="ÁÑ°Ê®ôÈ°åÊñáÁ´†"
            fi

            # Robust category extraction
            CATEGORY=""
            CATEGORY_RAW="$(echo "$file_content" | grep -A 1 -E '^\s*category:' | grep -E '^\s*-\s*' | head -n 1 | sed -E 's/^\s*-\s*(.*)/\1/' | sed -E 's/[\r\n]//g' | sed -E 's/^"|"//g' | sed -E "s/^\x27|\x27//g" | xargs)"
            if [[ -n "$CATEGORY_RAW" ]]; then
              CATEGORY="$CATEGORY_RAW"
              CATEGORY="$(echo "$CATEGORY" | tr -cd '[:alnum:] _-')"
              CATEGORY="$(echo "$CATEGORY" | xargs)"
            fi
            if [[ -z "$CATEGORY" ]]; then
              CATEGORY_RAW="$(echo "$file_content" | grep -iE '^\s*category:\s*\[.*\]' | head -n 1 | sed -E 's/^\s*category:\s*\[(.*)\].*/\1/' | cut -d',' -f1 | sed -E 's/[\r\n]//g' | sed -E 's/^"|"//g' | sed -E "s/^\x27|\x27//g" | xargs)"
              if [[ -n "$CATEGORY_RAW" ]]; then
                CATEGORY="$CATEGORY_RAW"
                CATEGORY="$(echo "$CATEGORY" | tr -cd '[:alnum:] _-')"
                CATEGORY="$(echo "$CATEGORY" | xargs)"
              fi
            fi
            if [[ -z "$CATEGORY" ]]; then
              CATEGORY_RAW="$(echo "$file_content" | grep -iE '^\s*category:\s*[^\[-]' | head -n 1 | sed -E 's/^\s*category:\s*(.*)/\1/' | sed -E 's/[\r\n]//g' | sed -E 's/^"|"//g' | sed -E "s/^\x27|\x27//g" | xargs)"
              if [[ -n "$CATEGORY_RAW" ]]; then
                CATEGORY="$CATEGORY_RAW"
                CATEGORY="$(echo "$CATEGORY" | tr -cd '[:alnum:] _-')"
                CATEGORY="$(echo "$CATEGORY" | xargs)"
              fi
            fi
            if [[ -n "$CATEGORY" ]]; then
                TITLE="„Äê${CATEGORY}„Äë${TITLE}"
            fi

            ARTICLE_SLUG="$(echo "$file_path" | sed -E 's|^blog/(.*)\.md$|\1|')"
            ARTICLE_URL="${BASE_URL}/blog/${ARTICLE_SLUG}.html"

            MESSAGE="**üì¢ New push to GitHub**\n"
            MESSAGE+="**${TITLE}**\n"
            MESSAGE+="\`\`\`${{ github.event.head_commit.message }}\`\`\`\n"
            MESSAGE+="[>>ÈªûÊ≠§Èñ±ËÆÄÊñáÁ´†](${ARTICLE_URL})\n"
            MESSAGE+="by ${{ github.event.head_commit.author.name }}"

            ENCODED_MESSAGE="$(echo -e "${MESSAGE}" | sed -E 's/([_*\[\]()~`>#+\-=\|{}!.\\])/\\\1/g' | sed 's/ /%20/g' | sed 's/\n/%0A/g' | sed 's/\*/%2A/g' | sed 's/\[/%5B/g' | sed 's/\]/%5D/g' | sed 's/`/%60/g')"

            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -d "chat_id=${TELEGRAM_CHAT_ID}" \
              -d "text=${ENCODED_MESSAGE}" \
              -d "parse_mode=MarkdownV2"
            echo "Telegram notification sent for ${file_path} with title: ${TITLE}"
          done
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
